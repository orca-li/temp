v0.1
```
 ██████╗███╗   ██╗████████╗██╗     ██╗██████╗ 
██╔════╝████╗  ██║╚══██╔══╝██║     ██║██╔══██╗
██║     ██╔██╗ ██║   ██║   ██║     ██║██████╔╝
██║     ██║╚██╗██║   ██║   ██║     ██║██╔══██╗
╚██████╗██║ ╚████║   ██║   ███████╗██║██████╔╝
 ╚═════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝╚═╝╚═════╝ 
```
# WHAT

# WHY

# HOWTO

## 1. Setup
```bash
cd your_project
git clone
```

```c
#include <stdio.h>
#include <cntlib.h>

int main()
{
    objcnt_t cnt = cntcnst(cnt);
    if (cnt == NULL) return 1;

    cntpp(cnt);
    printf("count: %d\n", cntvalue(cnt));

    return 0;
}
```

```bash
gcc -I"./cntlib" main.c
./a.out
```

## 2. Architecture

### LINK TYPE
#### ONE-WAY LINK
```
+-----+          +-----+
|     | -- -- -> |     |
|     |          |     |
+-----+          +-----+
```
Дает гарантию, что второй счетчик не может управлять первым
#### TWO-WAY LINK
```
+-----+          +-----+
|     | -- -- -> |     |
|     | <- -- -- |     |
+-----+          +-----+
```
Дает взаимную управления управления и подчинения

#### HOOK & LINK
```
     ______________
    /              \
   |                |
   v                v
+-----+          +-----+
|     | -- -- -> |     |
|     | <- -- -- |     |
+-----+          +-----+
```
Сложное, но возможное поведение. Лучше его не использовать.

### LINK ROLE
#### CHILD - PARENT
```
+-----+
|     | parent
|     |
+-----+
   ^
   |
   |
+-----+
|  @  | child
|     |
+-----+
```
Переполнение ребенка гарантирует, что parent выполнет оператор `plus`.

#### PARENT - CHILD
```
+-----+
|  @  | parent
|     |
+-----+
   |
   |
   v
+-----+
|     | child
|     |
+-----+
```
Шаг родителя гаранитуер, что child выполнит оператор `reset`.
#### PEER-TO-PEER
```
+-----+          +-----+
|  @  | -- -- -> |     |
|     | <- -- -- |     |
+-----+          +-----+
```
Вызов оператора `plus` гарантирует, что все остальные члены вызовут `plus`
#### FAMILY
```
+-----+          +-----+          
|     | -- -- -> |     | -- -- ->
|     | <- -- -> |     | <- -- ->  (...)            (...)
+-----+          +-----+          
   ^                ^                                 ^
   |                |                                 |
   |                v                                 v
+-----+          +-----+          +-----+          +-----+
|     | -- -- -> |     | -- -- -> |     | -- -- -> |     |
|     | <- -- -- |     | <- -- -> |     | -- -- -> |     |
+-----+          +-----+          +-----+          +-----+
   ^                                 ^                ^
   |                                 |                |
   v                                 v                v
+-----+          +-----+          +-----+
|     |          |     | -- -- -> |     |           (...)
|     |          |     | <- -- -> |     |
+-----+          +-----+          +-----+
```
Все счетчики которые косвенно связаны с другими счетчиками хотя бы одной связью. Создавая семейства счетчиков нужно избегать кольцевой вид связи. Нужно понимать и продумать поведение каждого типа и вида связи в семье.

### COUNTER TYPE
#### переполняемые

#### бесконечные

### COUNTER ROLE
#### REGION COUNTER
Счетчик перемещается по адресу. Когда заканчивается адрес, перемещается на другой счетчик. Продолжает перемещение по адресу как продолжение региона.

#### LOCATION COUNTER
Счетчик перемещается по адресу.

#### BIT COUNTER
Счетчик перемещается по адресу, но побитово.

#### OBJECT COUNTER
Счетчик просто считает числа(кол-во объектов).

### OPERATORS
#### PERSONAL
##### BUILD
```c
cntcnst(cnt, type);
cntdstr(cnt);
cntlink(cnt, type, cnt_a);
cntunlink(cnt, cnt_a);
```
##### STEP
```c
cntmv(cnt);             // cnt++; don't touch links;
cntmvl(cnt, addend);    // cnt += addend; don't touch links
cntmm(cnt);             // cnt--;
cntpp(cnt);             // cnt++;
cntadd(cnt, addend);    // cnt += addend;
cntidx(cnt, index);     // cnt[i];
cntset(cnt, cnt_a);     // cnt = cnt_a; // don't touch links
cntcpy(cnt, cnt_a);     // memcpy(cnt, cnt_a, sizeof(cnt));
```
##### CONTROL
```c
cntstart(cnt);          // while();
cntrst(cnt);            // continue;
cntstop(cnt);           // break;
```

##### GET
```c
cntvalue(cnt);          // x = cnt_index;
cntread(cnt);           // p = cnt; or *p = *cnt;
```

##### EVENT
```c
// call = void func(void);
cntev_step(cnt, &func);             // every step call
cntev_start(cnt, &func);            // if (start) call 
cntev_stop(cnt, &func);             // if (stop) call
cntev_overflow(cnt, &func);         // if (overflow) call
cntev_mark(cnt, mark, &func);       // if (count == mark) call
```
#### FAMILY
#####
```c

```
### OPERATORS TABLE

## 2. API

### Initialization
Чтобы создать счетчик нужно вызвать конструктор и провести инициализацию. Важное замечание, если вы не хотите, чтобы дочерний счетчик не инкрементировал родителя, присвойте limit = 0.
```c
objcnt_t loccnt = cntcnst();
cntinit(loccnt, buffer, stepsz, limit);
// code
// библиотека гарантирует, что все дочерние счетчики будут уничтожены
cntdstr(loccnt); // также не забываем про дестуктор нашего объекта
```
Также есть функция полного уничтожения, которая уничтожает всё семейство счетчиков. Т.е. все родительские счетчики, все синхронные счетчики и все дочерние счетчики и текущий счетчик.
```c
fcntkill(loccnt);
```

### Addressing
Счетчик обладает идентичной указателю адресацией. Также счетчик дает гарантию того, что все дочерние счетчики будут сброшены, а синхронные счетчики синхронизируют поведение вашего счетчика, т.е. повторят поведение.
```c
// каждая функция влияет на синхронные, дочерние и родительские счетчики
// любое переполнение сбрасывает дочерей и двигает родителя
cntpp(loccnt);              // loccnt++;
cntmm(loccnt);              // loccnt--;
cntrst(loccnt);             // loccnt &= ~loccnt;
cntadd(loccnt, addend);     // loccnt += addend; loccnt->child = reset
cntidx(loccnt, index);      // loccnt[i];
cntset(loccnt, othcnt);     // loccnt = othcnt;
                            // особенность: проверяет шаг указателя
```

### Data
Это то для чего вы создавали счетчик. Это чтобы получать из нее данные или давать по адресу новые данные. Заметьте, что вы не можете обращаться к данным счетчика напрямую. Потому что данные функции приватные.
```c
cntsize_t count = cntvalue(loccnt);
int data = *(int*)cntaddr(loccnt);
```

### Counter family
Также есть API для семейства счетчиков. Вы уже видели выше одну из её функций. К префиксу библиотеки добавляется еще один префикс (`f`)amily. Все эти функции работают рекурсивно на всё семейство, включая родителей, все синрохнные счетчики и все дочерние счетчики.
```c
fcntnew(cnt1, cnt2, cnt3, ..., NULL); // вызывает конструктор для каждого аргумента пока не встретит NULL
fcntkill(loccnt); // деструктор семейства
fcntrst(loccnt); // сброс семейства
```

# EXAMPLES

## Clocks

## Calendar

## Byte addressing

## Numbers

## File System

## Bit fields

# OOP

